package main

import (
	"bytes"
	"fmt"
	"go/format"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

	"golang.org/x/tools/go/packages"
)

type Generator struct {
	basePath string
	pattern string
	pkgName string
	regExp *regexp.Regexp
	pkgPaths []string

	buf bytes.Buffer // Accumulated output.
	output string
}

func NewGenerator(basePath, pattern, output string) Generator {
	//Prepare regexp pattern
	regExpString := pattern
	for i := 0; strings.Contains(regExpString, "*"); i++ {
		num := strconv.Itoa(i + 1)
		regExpString = strings.Replace(regExpString, "*", "(?P<Group_"+num+">.+)", 1)
	}
	regExpString = "^.*" + regExpString + ".*$"
	log.Println(regExpString)
	r := regexp.MustCompile(regExpString)
	log.Println("Groups: ", r.SubexpNames())
	// Prepare folders with possible files
	if !isDir(basePath) {
		log.Fatalf("The %s is not a directory", baseDir)
	}

	//Prepare package name
	pkgName := basePath
	if strings.Contains(basePath, "/") {
		pkgName = basePath[strings.LastIndex(basePath, "/") + 1:]
	}

	patt := basePath + pattern
	log.Println("Pattern: ", patt)
	m, err := filepath.Glob(basePath + pattern + "/*.go")
	if err != nil {
		log.Fatal(err)
	}

	paths := map[string]struct{}{}
	for _, v := range m {
		paths[v[:strings.LastIndex(v, "/")]] = struct{}{}
	}

	patterns := []string{}
	for k, _ := range paths {
		log.Println("folder: ", k)
		patterns = append(patterns, "./"+k)
	}

	return Generator{
		basePath: basePath,
		pattern: pattern,
		pkgName: pkgName,
		regExp:   r,
		pkgPaths: patterns,
		output:   output,
	}
}

func (g *Generator) Process() {
	// Load packages
	cfg := packages.Config{
		Mode:  packages.NeedTypes,
		Tests: false,
	}
	pkgs, err := packages.Load(&cfg, g.pkgPaths...)
	if err != nil {
		log.Fatal(err)
	}



	log.Printf("PKGS %+v\n", pkgs)

	// Process packages
	gen := []toGenerate{}
	for _, v := range pkgs {
		if len(v.Errors) != 0 {
			log.Fatal(v.Errors)
		}
		for _, n := range v.Types.Scope().Names() {
			ob := v.Types.Scope().Lookup(n)
			t, ok := ob.Type().(*types.Basic)
			if !ok {
				continue
			}
			if t.Info() & types.IsString == types.IsString{
				subPathes := g.regExp.FindStringSubmatch(v.Types.Path())[1:]
				gen = append(gen, toGenerate{
					pkg:       v.Types.Path(),
					subPath:   subPathes,
					constName: n,
					alias:     getAlias(subPathes),
				})
			}
		}
	}
	log.Printf("%+v\n", gen)

	// Code generation
	if len(gen) == 0 {
		log.Fatal("nothing to generate")
	}

	// Print the header and package clause.
	g.printf("// Code generated by \"constanter -basePath=%s -pattern=%s -output=%s\"; DO NOT EDIT.\n", g.basePath, g.pattern, g.output)
	g.printf("\n")
	g.printf("package %s", g.pkgName)
	g.printf("\n")

	// Create imports
	imps := map[string]string{}
	rm := &RecurMap{
		value: map[string]*RecurMap{},
	}

	for _, v := range gen {
		imps[v.alias] = v.alias + " \"" + v.pkg + "\""
		rm.Add(v)
	}

	g.printf("import (\n")
	for _, v := range imps {
		g.printf("\t%s\n", v)
	}
	g.printf(")\n\n")

	// Create constants map
	g.printf("var Constants = map")
	for i, _ := range gen[0].subPath {
		g.printf("[string]")
		if i == len(gen[0].subPath)-1 {
			g.printf("map[string]string{\n")
			break
		}
		g.printf("map")
	}

	// Add values to map
	g.printf(rm.PrintInitMap())
	g.printf("}")
}

func (g *Generator) WriteFile() {
	src := g.format()
	outputName := filepath.Join(g.basePath, strings.ToLower(g.output))
	err := ioutil.WriteFile(outputName, src, os.ModePerm)
	if err != nil {
		log.Fatal(err)
	}
}

func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func (g *Generator) printf(format string, args ...interface{}) {
	_, err := fmt.Fprintf(&g.buf, format, args...)
	if err != nil {
		log.Fatal(err)
	}
}


type toGenerate struct {
	pkg       string
	subPath   []string
	constName string
	alias     string
}

type RecurMap struct {
	key     string
	value   map[string]*RecurMap
	payload []struct {
		pkg       string
		alias     string
		constName string
	}
}

func (rm *RecurMap) Add(elem toGenerate) {
	if len(elem.subPath) == 0 {
		rm.payload = append(rm.payload, struct {
			pkg       string
			alias     string
			constName string
		}{elem.pkg, elem.alias, elem.constName})
		return
	}
	key := elem.subPath[0]
	newElem := toGenerate{
		pkg:       elem.pkg,
		subPath:   elem.subPath[1:],
		constName: elem.constName,
		alias:     elem.alias,
	}

	subRm, ok := rm.value[key]
	if !ok {
		subRm = &RecurMap{
			key:   key,
			value: map[string]*RecurMap{},
		}
		rm.value[key] = subRm
	}
	subRm.Add(newElem)
}

func (rm *RecurMap) PrintInitMap() string {
	out := ""
	if len(rm.payload) != 0 {
		for _, v := range rm.payload {
			out = out + "\"" + v.constName + "\":" + v.alias + "." + v.constName + ",\n"
		}
		return out
	}
	for k, v := range rm.value {
		out = out + "\"" + k + "\"" + ":{\n" + v.PrintInitMap() + "},\n"
	}
	return out
}

func getAlias(sub []string) string {
	out := "al"
	replacer := strings.NewReplacer(
		".", "_",
		"-", "_",
	)
	for _, v := range sub {
		out = out + "_" + replacer.Replace(v)
	}
	return out
}

func isDir(dir string) bool {
	i, err := os.Stat(dir)
	if err != nil {
		return false
	}
	return i.IsDir()
}
